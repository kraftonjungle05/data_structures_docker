
---

## ✅ 사용된 자료구조: **단일 연결 리스트 (Singly Linked List)**

### 📌 구성
```c
typedef struct _listnode {
    int item;
    struct _listnode *next;
} ListNode;
```

- `item`: 정수 데이터 (노드가 보관하는 값)
- `next`: 다음 노드를 가리키는 포인터

➡️ 이 구조를 통해 여러 개의 노드가 "사슬"처럼 연결되어 리스트를 구성함.

---

## ✅ 사용된 구조의 특성

| 특징 | 설명 |
|------|------|
| 단방향 링크 | 각 노드는 오직 **자기 다음 노드의 주소**만 저장함 |
| head 포인터 | 리스트의 시작점을 저장하는 포인터 (처음 노드 위치) |
| 동적 메모리 할당 | 리스트 크기를 정해놓지 않고 `malloc()`으로 필요할 때마다 확장 가능 |

---

## ✅ 핵심 동작: **리스트를 재귀적으로 뒤집기**
### ✔️ 어떤 구조로 이뤄졌는가?
- **이중 포인터 (`ListNode **ppHead`)**  
  → head 포인터 자체를 바꾸기 위해 사용
- **재귀 호출 구조**  
  → 리스트를 끝까지 탐색한 후, 되돌아가며 `next` 링크를 반대로 연결

---

## 🔁 전체 동작 요약
1. 리스트를 한 칸씩 나눠가며 `pFirst` (현재 노드), `pRest` (나머지 리스트)로 분리
2. `pRest`를 재귀 호출로 뒤집음
3. 뒤집힌 나머지 리스트의 끝에 `pFirst`를 연결
4. `pFirst`의 `next`를 `NULL`로 설정 → 리스트의 끝으로 만듦
5. head를 새로 갱신 (`*ppHead = pRest`)
---

## 🧠 자료구조 관점에서 중요한 점
| 요소 | 설명 |
|------|------|
| **연결 리스트** | 포인터를 활용한 대표적인 동적 자료구조 |
| **재귀** | 리스트의 끝에서부터 역으로 돌아오며 연결 수정 |
| **포인터 (Pointer)** | 노드 간 연결을 표현하고 head 변경을 위해 이중 포인터 사용 |
| **메모리 구조** | 리스트는 메모리 상에서 연속되지 않고, 노드마다 `next`를 통해 연결됨 |

---

## 🎯 핵심 포인트
- 이 함수는 **추가적인 배열이나 스택 등의 자료구조 없이**, 오직 **포인터와 재귀 호출**만으로 리스트를 뒤집음
- `ListNode` 구조체를 중심으로 구성된 **단일 연결 리스트**를 재구성함
- `ListNode **` 사용은 **자료구조의 시작(head)를 직접 바꾸기 위한 기법**임

---