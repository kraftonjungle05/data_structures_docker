## ✅ 구현해야 했던 함수

### 1. `createQueueFromLinkedList(LinkedList *ll, Queue *q)`

**목적**  
- 연결 리스트(`LinkedList`)에 저장된 데이터를 **큐(`Queue`)에 그대로 복사**하는 함수입니다.
- **앞에서부터 순서대로** 큐에 삽입되도록 해야 합니다.

**동작 과정**
1. 큐가 비어있지 않을 경우, 기존 데이터를 모두 `dequeue()`로 제거합니다.
2. 연결 리스트의 `size`만큼 동적 배열(`int *buffer`)을 할당하여 데이터를 저장합니다.
3. 연결 리스트를 순회하며 `buffer[i] = cur->item` 형태로 값을 배열에 담습니다.
4. 배열에 있는 값들을 다시 큐에 `enqueue()`를 통해 삽입합니다.
5. 동적 배열 `free(buffer)`로 메모리를 해제합니다.

**장점 (배열 사용)**
- 연결 리스트를 순회하며 값을 임시 저장하고,
- 메모리를 재사용하지 않고 큐를 깨끗하게 다시 구성할 수 있음.

---

### 2. `removeOddValues(Queue *q)`

**목적**  
- 큐에서 **홀수 값을 제거**하는 함수입니다.
- 큐에 남는 값은 **짝수 값만 유지**됩니다.

**동작 과정**
1. 큐의 현재 크기만큼의 동적 배열(`buffer`)을 생성합니다.
2. 큐를 `dequeue()` 하며 값이 **짝수인 경우만** 배열에 저장합니다.
3. 배열에 남긴 짝수 값들을 큐에 다시 `enqueue()`로 삽입합니다.
4. 사용한 배열은 `free()`로 메모리 해제합니다.

**배열 사용 이유**
- 큐는 FIFO 구조라 중간 요소 제거가 어렵습니다.
- 배열에 값을 모아두고, 조건에 맞는 값만 다시 삽입함으로써 **필터링 역할**을 수행.

---

## ✅ 배열을 사용한 삭제/삽입 정리

| 작업 | 설명 |
|------|------|
| 삭제 | 큐에서 값을 `dequeue()`하며 하나씩 꺼냄. 조건(짝수)에 맞지 않으면 배열에 저장하지 않음. |
| 삽입 | 배열에 저장된 값들을 `for`문을 통해 다시 `enqueue()`로 큐에 넣음. |
| 배열 장점 | 선별된 데이터를 재구성할 때 효율적. 메모리 접근이 빠르고 정렬된 상태 유지 가능. |
| 배열 단점 | 메모리 공간이 고정됨. 초과시 재할당 필요. 연결리스트보다 메모리 낭비가 있을 수 있음. |

---

### ✨ 정리하면

이 문제에서의 핵심은 **배열을 통해 선별과 재구성 작업을 분리**하여 효율적으로 처리했다는 점입니다. 연결리스트 기반 큐는 중간 삽입/삭제가 느리므로, 배열을 통해 **중간 조건 필터링** 후 전체 큐를 재구성하는 방식이 아주 적절하게 쓰였습니다.