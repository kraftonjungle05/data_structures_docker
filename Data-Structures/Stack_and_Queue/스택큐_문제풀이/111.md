
## ✅ 구현 함수 설명

---
### 1. `createQueueFromLinkedList(LinkedList *ll, Queue *q)`

#### 🔹 목적  
- 연결 리스트의 값을 **앞에서부터 순서대로 큐에 복사**합니다.

#### 🔹 구현 흐름 (코드 포함)

① **기존 큐 초기화**
```c
while (!isEmptyQueue(queue)) {
    dequeue(queue);
}
```
- 기존에 큐에 남아 있던 데이터를 모두 제거하여 초기화합니다.

② **배열 동적 할당**
```c
int size = linkedList->size;
int *buffer = (int *)malloc(sizeof(int) * size);
```
- 연결 리스트의 크기만큼의 `int` 배열을 할당하여 데이터를 임시 저장합니다.

③ **리스트 데이터를 배열에 복사**
```c
ListNode *cur = linkedList->head;
int i = 0;
while (cur != NULL && i < size) {
    buffer[i++] = cur->item;
    cur = cur->next;
}
```
- 리스트를 순회하면서 각 노드의 `item`을 `buffer`에 저장합니다.

④ **배열에서 큐로 복사**
```c
for (int j = 0; j < i; j++) {
    enqueue(queue, buffer[j]);
}
```
- 배열의 데이터를 다시 큐에 `enqueue()`합니다.

⑤ **메모리 해제**
```c
free(buffer);
```
- 작업이 끝난 후 메모리를 반환합니다.

---

### 2. `removeOddValues(Queue *q)`

#### 🔹 목적  
- 큐에 있는 **홀수 값들을 제거하고 짝수만 남김**.

#### 🔹 구현 흐름 (코드 포함)

① **현재 큐 크기만큼 배열 생성**
```c
int originalSize = queue->ll.size;
int *buffer = (int *)malloc(sizeof(int) * originalSize);
```
- 큐의 요소들을 임시 저장할 배열을 만듭니다.

② **짝수만 배열에 저장**
```c
int count = 0;
while (!isEmptyQueue(queue)) {
    int val = dequeue(queue);
    if (val % 2 == 0) {
        buffer[count++] = val;
    }
}
```
- `dequeue()` 하면서 **짝수 값만** 배열에 저장합니다.

③ **짝수 값만 큐에 다시 삽입**
```c
for (int i = 0; i < count; i++) {
    enqueue(queue, buffer[i]);
}
```
- 필터링된 짝수 값만 큐에 다시 넣습니다.

④ **메모리 해제**
```c
free(buffer);
```

---

## ✅ 배열을 사용한 삽입/삭제 요약

| 구분 | 코드 예시 | 설명 |
|------|-----------|------|
| 삭제 | `dequeue(queue);` | 조건 검사 없이 큐에서 하나씩 꺼냄 |
| 조건 저장 | `if (val % 2 == 0) buffer[count++] = val;` | 짝수만 배열에 저장 |
| 삽입 | `enqueue(queue, buffer[i]);` | 배열에서 큐로 복사 |
| 해제 | `free(buffer);` | 동적 메모리 반환 |

---

## ✅ 핵심 요약

- **연결 리스트 → 큐**로 옮길 때는 배열을 중간에 거쳐 순서를 유지.
- **짝수만 남기기** 위해 큐 → 배열 → 큐 구조 사용.
- **중간 삽입/삭제가 어려운 큐의 한계**를 배열로 극복.