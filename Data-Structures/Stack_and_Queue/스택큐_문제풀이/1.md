함수 이름 | 주요 동작 | 설명
createQueueFromLinkedList | 리스트 → 큐 | 연결 리스트 값을 순서대로 큐에 복사
removeOddValues | 큐 정리 | 큐에서 홀수 제거, 짝수만 유지

이 코드에서 구현해야 했던 함수는 `createQueueFromLinkedList()`와 `removeOddValues()`입니다. 이 두 함수는 **배열을 활용하여 연결 리스트 기반 큐를 효과적으로 조작**하고 있습니다. 아래에 각 함수에서 **배열을 어떻게 사용했는지** 자세히 설명드릴게요.

---
## ✅ `createQueueFromLinkedList()` 함수 – 배열 사용 방식
### 🔹 목적:
- 연결 리스트(`LinkedList`)에 저장된 데이터를 **큐(`Queue`)에 순서대로 삽입**.

### 🔹 배열 사용 흐름:
1. **큐 초기화**:
   ```c
   while (!isEmptyQueue(queue)) {
       dequeue(queue);
   }
   ```
   → 기존 큐에 값이 있을 수 있으므로 모두 제거합니다.

2. **연결 리스트 크기만큼 동적 배열 생성**:
   ```c
   int size = linkedList->size;
   int *buffer = (int *)malloc(sizeof(int) * size);
   ```
   → 리스트의 크기만큼 `int`형 배열 생성. 배열의 크기를 동적으로 설정하여 메모리를 효율적으로 사용합니다.

3. **연결 리스트 순회하며 배열에 값 저장**:
   ```c
   ListNode *cur = linkedList->head;
   int i = 0;
   while (cur != NULL && i < size) {
       buffer[i++] = cur->item;
       cur = cur->next;
   }
   ```
   → 리스트 노드를 하나씩 따라가며 `item` 값을 배열에 복사.

4. **배열에서 큐에 enqueue**:
   ```c
   for (int j = 0; j < i; j++) {
       enqueue(queue, buffer[j]);
   }
   ```
   → 배열에 저장한 순서 그대로 큐에 삽입.

5. **배열 메모리 해제**:
   ```c
   free(buffer);
   ```

### ✅ 요약:
- 배열은 **중간 저장소**로 활용되며, 연결 리스트 데이터를 큐로 변환할 때 안정적으로 사용됩니다.
- 배열은 순차 접근이 빠르고 정해진 메모리 공간 내에서 반복 작업을 쉽게 수행할 수 있습니다.

---

## ✅ `removeOddValues()` 함수 – 배열 사용 방식

### 🔹 목적:
- 큐에서 **홀수 값을 제거하고 짝수만 유지**하는 함수.

### 🔹 배열 사용 흐름:
1. **동적 배열 생성**:
   ```c
   int *buffer = (int *)malloc(sizeof(int) * originalSize);
   ```
   → 큐의 기존 크기만큼 배열 생성 (최악의 경우 전부 짝수일 수 있으므로 동일 크기 확보).

2. **큐에서 값을 꺼내면서 짝수만 배열에 저장**:
   ```c
   while (!isEmptyQueue(queue)) {
       int val = dequeue(queue);
       if (val % 2 == 0) {
           buffer[count++] = val;
       }
   }
   ```
   → 홀수는 버리고, 짝수만 배열에 저장.

3. **배열에서 큐로 다시 enqueue**:
   ```c
   for (int i = 0; i < count; i++) {
       enqueue(queue, buffer[i]);
   }
   ```

4. **배열 메모리 해제**:
   ```c
   free(buffer);
   ```

### ✅ 요약:
- 큐는 중간 삽입/삭제가 어려우므로, 조건 필터링이 필요한 경우 배열이 유용합니다.
- 배열을 통해 원하는 값만 선별하여 **새로운 큐 구조를 만들듯 다시 enqueue**하는 방식입니다.

---

## 📌 전체적으로 배열을 사용한 이유:

| 이유 | 설명 |
|------|------|
| 중간 삭제의 어려움 보완 | 연결 리스트 기반 큐는 중간 삭제가 비효율적. 배열은 조건에 맞는 값을 모아서 처리 가능. |
| 메모리 관리 | 필요한 만큼만 동적 할당하여 공간을 효율적으로 사용. |
| 필터링 기능 | 특정 조건(홀수 제거 등)을 만족하는 요소만 선별하여 처리. |
| 코드 안정성 | 원본 큐나 리스트의 구조를 직접 변경하지 않고, 배열에 임시 저장 후 재구성 가능. |

---

이 코드에서 구현해야 했던 함수는 `createQueueFromLinkedList()`와 `removeOddValues()`입니다. 이 두 함수는 **배열을 활용하여 연결 리스트 기반 큐를 효과적으로 조작**하고 있습니다. 아래에 각 함수에서 **배열을 어떻게 사용했는지** 자세히 설명드릴게요.

---

## ✅ `createQueueFromLinkedList()` 함수 – 배열 사용 방식

### 🔹 목적:
- 연결 리스트(`LinkedList`)에 저장된 데이터를 **큐(`Queue`)에 순서대로 삽입**.

### 🔹 배열 사용 흐름:
1. **큐 초기화**:
   ```c
   while (!isEmptyQueue(queue)) {
       dequeue(queue);
   }
   ```
   → 기존 큐에 값이 있을 수 있으므로 모두 제거합니다.

2. **연결 리스트 크기만큼 동적 배열 생성**:
   ```c
   int size = linkedList->size;
   int *buffer = (int *)malloc(sizeof(int) * size);
   ```
   → 리스트의 크기만큼 `int`형 배열 생성. 배열의 크기를 동적으로 설정하여 메모리를 효율적으로 사용합니다.

3. **연결 리스트 순회하며 배열에 값 저장**:
   ```c
   ListNode *cur = linkedList->head;
   int i = 0;
   while (cur != NULL && i < size) {
       buffer[i++] = cur->item;
       cur = cur->next;
   }
   ```
   → 리스트 노드를 하나씩 따라가며 `item` 값을 배열에 복사.

4. **배열에서 큐에 enqueue**:
   ```c
   for (int j = 0; j < i; j++) {
       enqueue(queue, buffer[j]);
   }
   ```
   → 배열에 저장한 순서 그대로 큐에 삽입.

5. **배열 메모리 해제**:
   ```c
   free(buffer);
   ```

### ✅ 요약:
- 배열은 **중간 저장소**로 활용되며, 연결 리스트 데이터를 큐로 변환할 때 안정적으로 사용됩니다.
- 배열은 순차 접근이 빠르고 정해진 메모리 공간 내에서 반복 작업을 쉽게 수행할 수 있습니다.

---

## ✅ `removeOddValues()` 함수 – 배열 사용 방식

### 🔹 목적:
- 큐에서 **홀수 값을 제거하고 짝수만 유지**하는 함수.

### 🔹 배열 사용 흐름:
1. **동적 배열 생성**:
   ```c
   int *buffer = (int *)malloc(sizeof(int) * originalSize);
   ```
   → 큐의 기존 크기만큼 배열 생성 (최악의 경우 전부 짝수일 수 있으므로 동일 크기 확보).

2. **큐에서 값을 꺼내면서 짝수만 배열에 저장**:
   ```c
   while (!isEmptyQueue(queue)) {
       int val = dequeue(queue);
       if (val % 2 == 0) {
           buffer[count++] = val;
       }
   }
   ```
   → 홀수는 버리고, 짝수만 배열에 저장.

3. **배열에서 큐로 다시 enqueue**:
   ```c
   for (int i = 0; i < count; i++) {
       enqueue(queue, buffer[i]);
   }
   ```
4. **배열 메모리 해제**:
   ```c
   free(buffer);
   ```

### ✅ 요약:
- 큐는 중간 삽입/삭제가 어려우므로, 조건 필터링이 필요한 경우 배열이 유용합니다.
- 배열을 통해 원하는 값만 선별하여 **새로운 큐 구조를 만들듯 다시 enqueue**하는 방식입니다.

---

## 📌 전체적으로 배열을 사용한 이유:

| 이유 | 설명 |
|------|------|
| 중간 삭제의 어려움 보완 | 연결 리스트 기반 큐는 중간 삭제가 비효율적. 배열은 조건에 맞는 값을 모아서 처리 가능. |
| 메모리 관리 | 필요한 만큼만 동적 할당하여 공간을 효율적으로 사용. |
| 필터링 기능 | 특정 조건(홀수 제거 등)을 만족하는 요소만 선별하여 처리. |
| 코드 안정성 | 원본 큐나 리스트의 구조를 직접 변경하지 않고, 배열에 임시 저장 후 재구성 가능. |
---