# 📘 발표문: 연결 리스트 → 큐 변환 및 필터링 구현
## 🔍 주제 개요
- **구현 목표**:
  - 연결 리스트를 큐로 변환 (`createQueueFromLinkedList`)
  - 큐에서 홀수 제거 (`removeOddValues`)
---

## 📄 구현 함수 목록

| 함수명 | 위치 | 역할 |
|--------|------|------|
| `createQueueFromLinkedList` | Line **129** | 연결 리스트의 데이터를 큐로 변환 |
| `removeOddValues` | Line **148** | 큐에서 홀수 제거, 짝수만 유지 |
---

## ✅ 함수 1: `createQueueFromLinkedList` (Line 129)
### 🧠 목적:
- 연결 리스트(`LinkedList`)의 모든 데이터를 **큐(`Queue`)에 순서대로 복사**하는 기능

### 📌 주요 로직:
#### 🔹 1) 큐 초기화 (Line 133)
```c
while (!isEmptyQueue(queue)) {
    dequeue(queue);
}
```
> 기존 큐가 비어있지 않을 수 있으므로 **안정성을 위해 모든 원소 제거**.

#### 🔹 2) 동적 배열 생성 (Line 136)
```c
int *buffer = (int *)malloc(sizeof(int) * size);
```
> 연결 리스트의 `size`만큼 배열 생성. **중간 저장소로서 배열 사용**.

#### 🔹 3) 연결 리스트 → 배열 복사 (Line 140~144)
```c
while (cur != NULL && i < size) {
    buffer[i++] = cur->item;
    cur = cur->next;
}
```
> 리스트를 순회하며 값 저장.

#### 🔹 4) 배열 → 큐 삽입 (Line 147)
```c
enqueue(queue, buffer[j]);
```
> 배열에 저장한 값을 순서대로 큐에 enqueue.

#### 🔹 5) 메모리 해제 (Line 150)
```c
free(buffer);
```

---

## ✅ 함수 2: `removeOddValues` (Line 148)

### 🧠 목적:
- 큐에서 **홀수만 제거**, **짝수만 남기는** 필터링 작업 수행

### 📌 주요 로직:
#### 🔹 1) 배열 생성 (Line 152)
```c
int *buffer = (int *)malloc(sizeof(int) * originalSize);
```
> 큐의 원래 크기만큼 배열 할당. **최악의 경우 모든 값이 짝수일 수 있기 때문**.

#### 🔹 2) 큐에서 값을 꺼내고 조건 필터링 (Line 156~160)
```c
if (val % 2 == 0) {
    buffer[count++] = val;
}
```
> 홀수는 버리고, **짝수만 배열에 저장**.

#### 🔹 3) 배열 → 큐 재삽입 (Line 163~165)
```c
enqueue(queue, buffer[i]);
```
> 새로운 구조처럼 **큐를 재구성**.

#### 🔹 4) 메모리 해제 (Line 167)
```c
free(buffer);
```

---

## 📦 배열 사용 이유

| 이유 | 설명 |
|------|------|
| ✅ 중간 삭제 우회 | 큐는 중간 삭제가 비효율적 → 배열 사용 시 조건 필터링이 쉬움 |
| ✅ 메모리 효율 | `malloc`으로 필요한 만큼만 할당 |
| ✅ 구조 보존 | 원본 리스트/큐를 직접 변경하지 않음 |
| ✅ 순서 유지 | 배열 사용으로 순서가 정확히 유지됨 |

---

## 📌 결론

- 두 함수는 **배열을 중간 매개체로 사용**하여 **큐의 삽입, 삭제, 필터링 작업을 안정적으로 구현**했습니다.
- **연결 리스트 기반 큐의 한계를 보완**하고, **배열의 순차 접근 성능**을 적극 활용한 구조입니다.

---